
**ADR: 2023-09.2 - Выбор технологии программирования серверной части**

**Дата:** 20 сентября 2023 г.

**Статус:** Принято

**Контекст:** 

**Контекст:**  
При разработке серверной части нашей платформы для управления рецептами мы стоим перед выбором технологии программирования. Этот выбор будет влиять на скорость разработки, стабильность, производительность, и возможность привлечения квалифицированных разработчиков.

**Рассмотренные варианты:**  
**Рассмотренные варианты:**  
1. **Java:** Зрелый, проверенный язык с большой экосистемой (Spring, Jakarta EE), богатой поддержкой БД и enterprise-инструментами. Подходит для крупных систем; требует JVM/GC‑tuning, может иметь более долгий cold‑start/размер памяти.  
2. **Kotlin:** Современный язык на JVM, полностью совместим с Java, более лаконичный синтаксис, корутины для асинхронности. Удобен при миграции с Java‑стека и для команд, ищущих более выразительный синтаксис.  
3. **Go:** Компилируемый, быстрый язык с простым синтаксисом и эффективной поддержкой конкурентности (goroutines). Хорош для сетевых/инфраструктурных сервисов, даёт небольшие бинарники и быстрый запуск; ограниченность стандартной библиотеки и экосистемы для некоторых enterprise‑задач.  
4. **Python:** Очень быстрый цикл разработки, богатые библиотеки для аналитики и ML. Подходит для прототипов и сервисов с низким требованием по latency; GIL и интерпретируемость могут ограничивать throughput в CPU‑интенсивных сценариях.  
5. **C# (.NET / ASP.NET Core):** Кроссплатформенный современный стек с высокой производительностью (Kestrel), развитой поддержкой async/await, встроенной поддержкой gRPC/OpenAPI, зрелыми библиотеками для безопасности, identity и интеграций. Хорошие инструменты разработки (Visual Studio/VS Code), простая контейнеризация и сильная поддержка от Microsoft; удобен для команд на Windows и для деплоя в Linux‑кластере.


**Решение:**  
Выбран C# (.NET / ASP.NET Core).

**Обоснование:**  
- Производительность и предсказуемость: ASP.NET Core + Kestrel даёт высокую пропускную способность и низкую латентность в сценариях HTTP/gRPC.  
- Асинхронность и модель concurrency: удобный async/await, Task‑based concurrency и хорошо проработанные скоупы DI.  
- Экосистема для микросервисов: встроенная поддержка gRPC, OpenAPI (Swagger), health checks, middleware для политики безопасности, интеграция с OpenTelemetry.  
- Инструментарий и CI/CD на Windows и Linux: отличная поддержка в Visual Studio/VS Code, удобная отладка на локальной Windows‑машине и в контейнерах.  
- Платформенная зрелость: долгосрочная поддержка от Microsoft, обширные библиотеки для работы с базами, кешем, очередями и identity (OAuth2/OIDC).  
- Контейнеризация и оркестрация: лёгкая упаковка в Docker, проверенные практики деплоя в Kubernetes.  
- Совместимость с требованиями безопасности: удобная интеграция mTLS, JWT, policy handlers, middleware для аудита и логирования.  
- Поддержка Windows‑специфичных сценариев и при этом кроссплатформенность — полезно для разработки на рабочей станции Windows и деплоя в Linux-кластере.

**Недостатки/ограничения:**  
- Требуется соблюдение стандартов и шаблонов для уменьшения разнородности реализаций в разных командах.  
- Лицензионно‑организационные аспекты при использовании коммерческих инструментов (по необходимости).  
- Команде может понадобиться обучение при переходе с другого стека.

**Последствия:**  
- Все новые серверные микросервисы разрабатываются на C# / .NET.  
- Установить рекомендуемый минимум стека: .NET SDK (LTS), ASP.NET Core, gRPC/OpenAPI, OpenTelemetry, Serilog/structured logging, Health checks.  
- Стандарты кода и шаблоны сервисов (project templates) — обязательны для единообразия.  
- CI/CD‑профили и Dockerfile‑шаблоны — подготовить и включить в репозитории.  
- Интеграция с выбранными платформенными компонентами (API Gateway, Service Mesh, identity provider, секрет‑менеджер, мониторинг) — обязательна.

**Рекомендованные шаги внедрения:**  
1. Зафиксировать версию .NET (LTS) и базовый набор пакетов/шаблонов.  
2. Создать шаблон микросервиса (HTTP + gRPC, OpenAPI, health, logging, metrics, config).  
3. Настроить CI/CD pipeline (build, test, containerize, deploy).  
4. Внедрить OpenTelemetry + централизованный лог/trace/metrics.  

